
- 但是 大模型的记忆不能是无限的

### 做限制

```
希望保留20条上下文历史记录。整个的上下文呢，不要超过一兆。时间不要超过3天。
```

- 大模型 不能无限使用
	1. 条数限制
	2. 空间限制
	3. 时间限制

```
from openai import OpenAI
import json
import time

# 创建OpenAI客户端
client = OpenAI(
    base_url='https://api-inference.modelscope.cn/v1',    api_key='ms-a34dfa4e-fa08-485b-94f1-a72a47e7eae5', # ModelScope Token
)

# 配置参数
MAX_HISTORY_COUNT = 20  # 最多保留20条上下文记录
MAX_CONTEXT_SIZE = 1 * 1024 * 1024  # 上下文最大大小，1MB
MAX_HISTORY_DAYS = 3  # 上下文最大保留时间，3天

# 初始化对话历史，包含系统提示词
conversation_history = [
    {
        'role': 'system',
        'content': '你是一个记忆力很强的助手，能够记住对话的上下文，并根据之前的对话内容进行回复。',
        'timestamp': time.time()  # 添加时间戳
    }
]

def clean_history():
    """清理对话历史，确保满足数量、大小和时间限制"""
    global conversation_history
    
    # 1. 移除超出时间限制的历史记录（保留系统消息）
    current_time = time.time()
    cutoff_time = current_time - (MAX_HISTORY_DAYS * 24 * 60 * 60)  # 3天前的时间戳
    
    # 系统消息不计入时间限制
    system_message = None
    if conversation_history and conversation_history[0]['role'] == 'system':
        system_message = conversation_history[0]
        conversation_history = conversation_history[1:]
    
    conversation_history = [msg for msg in conversation_history 
                           if msg.get('timestamp', 0) >= cutoff_time]
    
    # 重新添加系统消息
    if system_message:
        conversation_history.insert(0, system_message)
    
    # 2. 限制历史记录数量（不包括系统消息）
    system_count = 1 if conversation_history and conversation_history[0]['role'] == 'system' else 0
    if len(conversation_history) - system_count > MAX_HISTORY_COUNT:
        # 保留系统消息，然后只保留最新的MAX_HISTORY_COUNT条消息
        if system_count:
            system_message = conversation_history[0]
            recent_messages = conversation_history[-MAX_HISTORY_COUNT:]
            conversation_history = [system_message] + recent_messages
        else:
            conversation_history = conversation_history[-MAX_HISTORY_COUNT:]
    
    # 3. 检查并控制上下文大小（不包括系统消息）
    while True:
        # 序列化对话历史（不包括系统消息）来计算大小
        if system_count:
            content_to_check = conversation_history[1:]
        else:
            content_to_check = conversation_history
        
        # 计算当前大小
        current_size = len(json.dumps(content_to_check))
        
        # 如果大小合适，退出循环
        if current_size <= MAX_CONTEXT_SIZE or len(content_to_check) <= 1:
            break
        
        # 否则移除最早的一条消息（不包括系统消息）
        if system_count:
            conversation_history.pop(1)
        else:
            conversation_history.pop(0)

print("欢迎使用智能对话助手！我会记住我们之间的对话内容。")
print("输入 '退出' 或 'exit' 可以结束对话。\n")

# 主循环，支持多轮对话
while True:
    # 获取用户输入
    user_input = input("你: ")
    
    # 检查是否退出
    if user_input.lower() in ['退出', 'exit']:
        print("助手: 再见！有需要随时找我。")
        break
    
    # 将用户输入添加到对话历史
    conversation_history.append({
        'role': 'user',
        'content': user_input,
        'timestamp': time.time()
    })
    
    # 清理历史记录，确保满足限制条件
    clean_history()
    
    try:
        # 准备发送给API的消息（移除时间戳）
        messages_for_api = [{k: v for k, v in msg.items() if k != 'timestamp'} 
                           for msg in conversation_history]
        
        # 发送请求到模型
        response = client.chat.completions.create(
            model='Qwen/Qwen3-Next-80B-A3B-Instruct', # ModelScope Model-Id
            messages=messages_for_api,
            stream=True
        )
        
        print("助手: ", end='')
        assistant_reply = ""
        
        # 处理流式响应
        for chunk in response:
            if chunk.choices[0].delta.content:
                print(chunk.choices[0].delta.content, end='', flush=True)
                assistant_reply += chunk.choices[0].delta.content
        
        print()  # 换行
        
        # 将助手回复添加到对话历史
        conversation_history.append({
            'role': 'assistant',
            'content': assistant_reply,
            'timestamp': time.time()
        })
        
        # 再次清理历史记录，确保添加助手回复后仍然满足限制条件
        clean_history()
        
    except Exception as e:
        print(f"发生错误: {e}")
```


