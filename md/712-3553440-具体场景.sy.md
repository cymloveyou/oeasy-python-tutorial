---
show: step
version: 1.0
enable_checker: true
---

# 实验标题

## 实验介绍

这是一段示例实验介绍。

#### 知识点

- 知识点 1
- 知识点 2

## 森林中的二人

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/3553440/uid1190679-20250209-1739068272253) 

```
import bpy
import math
import random

def create_material(name, color):
    mat = bpy.data.materials.new(name=name)
    mat.diffuse_color = (*color, 1)
    return mat

# 创建立方体的函数（支持角度输入）
def create_cube(name, location, rotation_deg, scale, material=None):
    bpy.ops.mesh.primitive_cube_add(location=location, size=2)  # 添加立方体
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale  # 设置缩放比例    
    # 将角度转换为弧度
    rotation_rad = (math.radians(rotation_deg[0]), math.radians(rotation_deg[1]), math.radians(rotation_deg[2]))   
    # 设置旋转角度
    obj.rotation_euler = rotation_rad    
    if material:
        obj.data.materials.append(material)  # 如果有材质，则附加材质    
    return obj

def create_sphere(name, location, scale, material=None):
    bpy.ops.mesh.primitive_uv_sphere_add(radius=1, location=location)
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale
    if material:
        obj.data.materials.append(material)
    return obj

def create_cone(name, location, rotation_deg,scale, material=None):
    bpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=location)
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale
    rotation_rad = (math.radians(rotation_deg[0]), math.radians(rotation_deg[1]), math.radians(rotation_deg[2]))   
    obj.rotation_euler = rotation_rad   
    if material:
        obj.data.materials.append(material)
    return obj

def create_cylinder(name, location, rotation_deg, scale, material=None):
    bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=location)
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale
     # 将角度转换为弧度
    rotation_rad = (math.radians(rotation_deg[0]), math.radians(rotation_deg[1]), math.radians(rotation_deg[2]))   
    # 设置旋转角度
    obj.rotation_euler = rotation_rad
    if material:
        obj.data.materials.append(material)
    return obj

# 创建环形体（Torus）的函数
def create_torus(name, location, major_radius, minor_radius, scale, material=None):
    bpy.ops.mesh.primitive_torus_add(location=location, major_radius=major_radius, minor_radius=minor_radius)  # 添加环形体
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale
    if material:
        obj.data.materials.append(material)  # 如果有材质，则附加材质
    return obj

# 创建日光
def add_sun_light():
    # 添加一个光源，类型为 "SUN"
    bpy.ops.object.light_add(type='SUN', location=(0, 0, 10))  # 位置可以调整
    sun = bpy.context.object
    sun.name = "SunLight"
    # 设置光源强度（光的能量）
    sun.data.energy = 2.5  # 设置光源的强度，数值可以调整
    # 设置光源颜色
    sun.data.color = (1, 1, 0.8)  # 近似黄色的光
    # 设置光源的方向
    sun.rotation_euler = (math.radians(45), math.radians(0), math.radians(45))  # 设置光照角度，模拟太阳的位置


def create_girl():
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    
    skin_mat = create_material("Skin", (1, 0.8, 0.6))
    eye_white_mat = create_material("EyeWhite", (1, 1, 1))
    eye_black_mat = create_material("EyeBlack", (0, 0, 0))
    cloth_mat = create_material("Cloth", (1, 0.5, 0))
    headband_mat = create_material("Headband", (0, 0, 0.8))
    
    head = create_sphere("Head", (0, 0, 1.56), (0.3, 0.3, 0.3), skin_mat)
    
    left_eye = create_sphere("LeftEye", (-0.243953, -0.133555, 1.62303), (0.055,0.055,0.055), eye_white_mat)
    right_eye = create_sphere("RightEye", (-0.243953, 0.133555, 1.62303), (0.055,0.055,0.055), eye_white_mat)
    left_pupil = create_sphere("LeftPupil", (-0.3, -0.133555, 1.62303), (0.02,0.02,0.02), eye_black_mat)
    right_pupil = create_sphere("RightPupil",(-0.3, 0.133555, 1.62303), (0.02,0.02,0.02), eye_black_mat)
    nose = create_cube("Nose", (-0.262794, 0, 1.52), (0,12,0), (0.059, 0.02, 0.059), skin_mat)
    headband = create_sphere("Headband", (0, 0, 1.85), (0.3, 0.3, 0.106), headband_mat)

    body = create_cone("Body", (0, 0, 1),(0,0,0) ,(0.418, 0.418, 0.418), cloth_mat)
    left_arm = create_cylinder("LeftArm", (0, -0.32, 1.2), (-127, 0, 0), (0.072, 0.072, 0.26), skin_mat)
    right_arm = create_cylinder("RightArm", (0, 0.328, 1), (73, 0, 0), (0.072, 0.072,0.26), skin_mat)
    left_hand = create_sphere("LeftHand",(-0.002476, -0.558189, 1.38772), (0.1, 0.1, 0.1), skin_mat)
    right_hand = create_sphere("RightHand",(-0.002476, 0.610417, 0.914956), (0.1, 0.1, 0.1), skin_mat)
    
    left_leg = create_cylinder("LeftLeg", (0, -0.1, 0.38441), (0, 0, 0), (0.072, 0.072, 0.26), skin_mat)
    right_leg = create_cylinder("RightLeg", (0, 0.1, 0.38441), (0, 0, 0), (0.072, 0.072,0.26), skin_mat)
    left_foot = create_sphere("LeftFoot",(0, -0.1, 0.089822), (0.1, 0.1, 0.1), skin_mat)
    right_foot = create_sphere("RightFoot",(0, 0.1, 0.089822), (0.1, 0.1, 0.1), skin_mat)
    
    girl = bpy.data.objects.new("Girl", None)
    bpy.context.collection.objects.link(girl)
    for obj in [head, left_eye, right_eye, left_pupil, right_pupil, nose, 
    headband, body,  left_arm, right_arm, left_hand, right_hand, left_leg, 
    right_leg, left_foot, right_foot]:
        obj.parent = girl
    
    print("Girl created successfully!")
    
def create_snowman():
    snow_mat = create_material("Snow", (1, 1, 1))
    eye_black_mat = create_material("EyeBlack",(0,0,0))
    hat_mat = create_material("Hat",(1,0,0))
    nose_mat = create_material("Nose",(1,0.2,0))
    arm_mat = create_material("Arm",(0.9,0.4,0))
        
    head = create_sphere("Head", (0,1.3141,1),(0.278,0.278,0.278),snow_mat)
    body = create_sphere("Body",(0,1.3141,0.4),(0.4,0.4,0.4),snow_mat)  
    left_eye = create_sphere("LeftEye",(-0.213425 ,1.2213,1.0916),(0.042,0.042,0.042),eye_black_mat) 
    right_eye = create_sphere("RightEye",(-0.213425 ,1.40547,1.0916),(0.042,0.042,0.042),eye_black_mat)
    hat = create_cone("Hat",(0,1.3141,1.3831),(0,0,0),(0.21,0.21,0.21),hat_mat)
    hat_ball = create_sphere("HatBall",(0,1.3141,1.5811),(0.072,0.072,0.072),snow_mat)
    nose = create_cone("Nose",(-0.33468,1.3141,0.97731),(0,-90,0),(0.045,0.045,0.135),nose_mat)
    scarf = create_torus("Scarf",(0,1.3141,0.78305),1,0.25,(0.215,0.215,0.215), hat_mat)
    shawl = create_cube("Shawl",(0.21787,0.926674,0.517964),(-43.1032,0,28.6661),(0.139,0.02,0.383),hat_mat)
    left_arm = create_cylinder("LeftArm",(0,0.895892,0.679607),(43.2376,0,0),(0.031,0.031,0.249),arm_mat)
    right_arm = create_cylinder("RightArm",(0,1.7517,0.679607),(-43.2376,0,0),(0.031,0.031,0.249),arm_mat)
    left_hand = create_sphere("LeftHand",(0,0.71859,0.86714),(0.06,0.06,0.06),snow_mat)
    right_hand = create_sphere("RightHand",(0,1.93773,0.86714),(0.06,0.06,0.06),snow_mat)
    
    snowman = bpy.data.objects.new("Snowman", None)
    bpy.context.collection.objects.link(snowman)
    for obj in [head, left_eye, right_eye, hat,hat_ball, nose, scarf, shawl,
    body,  left_arm, right_arm, left_hand, right_hand]:
        obj.parent = snowman
 
def create_house():
    wall_mat = create_material("Wall",(0.6,0.6,0.6))
    wood_mat = create_material("Wood",(0.9,0.4,0))
    roof_mat = create_material("Roof",(0.8,0.8,0.1))

    
    wall = create_cube("Wall",(-6.15605 ,4.35755 ,2.83782 ),(0,0,-25),(2.936,2.936,2.936),wall_mat)
    roof = create_cone("Roof",(-6.15605,4.3576,7.5574),(0,0,0),(5,5,2),roof_mat)
    door = create_cube("Door",(-3.1506,3.6743,1.2088),(0,0,-25),(0.043,0.732,1.252),wood_mat)
    window = create_cube("Window",(-4.0674,1.9061,4.1483),(0,0,-25),(0.079,0.8,0.59),wood_mat)


def create_tree(num_trees=10, radius=5, inner_radius=2, seed=42):
    random.seed(seed)  # 设置随机种子，确保每次生成的树位置一致
    
    trunk_mat = create_material("TreeTrunkMaterial", (0.6, 0.3, 0.1))  # 树干材质（棕色）
    tree_mat = create_material("TreeMaterial", (0.1, 0.5, 0.1))  # 树冠材质（绿色）
    
    for i in range(num_trees):
        # 随机决定树的大小
        tree_size = random.choice(["small", "medium", "large"])

       # 使用随机种子计算树的位置
        while True:
            angle = random.uniform(0, 2 * math.pi)  # 随机生成角度
            r = random.uniform(0, radius)  # 随机生成半径
            x = r * math.cos(angle)  # 极坐标转笛卡尔坐标
            y = r * math.sin(angle)  # 极坐标转笛卡尔坐标
            z = 0  # 高度保持在雪地上

            # 检查是否位于排除的区域内
            if r >= inner_radius:  # 如果树的位置距离中心至少是 inner_radius，继续生成
                break  # 退出循环，开始生成树

        # 树干（圆柱）
        trunk_height = random.uniform(1, 3)
        bpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=trunk_height, location=(x, y, z + trunk_height / 2))
        trunk = bpy.context.object
        trunk.name = "TreeTrunk"
        trunk.data.materials.append(trunk_mat)
        
        # 树冠（圆锥）
        if tree_size == "small":
            # 小树只有一个圆锥
            bpy.ops.mesh.primitive_cone_add(vertices=20, radius1=1, radius2=0, depth=2, location=(x, y, z + trunk_height + 1))
            tree_top = bpy.context.object
            tree_top.name = "TreeTop"
            tree_top.scale = (0.8, 0.8, 1)
        
        elif tree_size == "medium":
            # 中树有两个圆锥
            # 下部圆锥
            bpy.ops.mesh.primitive_cone_add(vertices=20, radius1=1.5, radius2=0, depth=2, location=(x, y, z + trunk_height+1))
            tree_top1 = bpy.context.object
            tree_top1.name = "TreeTop1"
            
            # 上部圆锥
            bpy.ops.mesh.primitive_cone_add(vertices=20, radius1=1, radius2=0, depth=1.5, location=(x, y, z + trunk_height +2))
            tree_top2 = bpy.context.object
            tree_top2.name = "TreeTop2"
            tree_top2.scale = (0.7, 0.7, 1)
        
        elif tree_size == "large":
            # 大树有三个圆锥
            # 下部圆锥
            bpy.ops.mesh.primitive_cone_add(vertices=20, radius1=1.8, radius2=0, depth=3, location=(x, y, z + trunk_height + 1))
            tree_top1 = bpy.context.object
            tree_top1.name = "TreeTop1"
            
            # 中部圆锥
            bpy.ops.mesh.primitive_cone_add(vertices=20, radius1=1.5, radius2=0, depth=2, location=(x, y, z + trunk_height + 2))
            tree_top2 = bpy.context.object
            tree_top2.name = "TreeTop2"
            tree_top2.scale = (0.8, 0.8, 1)
            
            # 上部圆锥
            bpy.ops.mesh.primitive_cone_add(vertices=20, radius1=1, radius2=0, depth=1.5, location=(x, y, z + trunk_height + 3))
            tree_top3 = bpy.context.object
            tree_top3.name = "TreeTop3"
            tree_top3.scale = (0.6, 0.6, 1)


        if tree_size == "small":
            tree_top.data.materials.append(tree_mat)
        elif tree_size == "medium":
            tree_top1.data.materials.append(tree_mat)
            tree_top2.data.materials.append(tree_mat)
        elif tree_size == "large":
            tree_top1.data.materials.append(tree_mat)
            tree_top2.data.materials.append(tree_mat)
            tree_top3.data.materials.append(tree_mat)



def create_env():
    snow_mat = create_material("SnowPlane",(1,1,1))
    
    snow_plane = create_cylinder("SnowPlane",(0,0,-0.1),(0,0,0),(12,12,0.1),snow_mat)    
    
    

    
create_girl()
create_snowman()
create_house()
create_tree(30,11,5,2)
create_env()
add_sun_light()
```

### 湖边看鸭子的小熊

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/3553440/uid1190679-20250209-1739069295798) 

```
import bpy
import math
import random

bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()


def create_material(name, color):
    mat = bpy.data.materials.new(name=name)
    mat.diffuse_color = (*color, 1)
    return mat

def create_duck(location):
    body_mat = create_material("DuckBody", (1, 1, 0))  # 黄色材质
    beak_mat = create_material("DuckBeak", (1, 0.6, 0))  # 橙色材质
    wing_mat = create_material("DuckWing", (0.8, 0.8, 0))  # 黄绿色材质
    eye_mat = create_material("DuckEye", (0, 0, 0))  # 黑色眼睛材质

    # 鸭子的身体（使用球体代替）
    body = create_sphere("DuckBody", location, (0.3, 0.3, 0.2), body_mat)  # 球体作为鸭子的身体
    body.location = location  # 设置位置

    # 鸭子的头部（使用球体代替）
    head = create_sphere("DuckHead", (location[0], location[1], location[2] + 0.2), (0.2, 0.2, 0.2), body_mat)

    # 鸭子的嘴巴（使用球体代替，缩小）
    beak = create_sphere("DuckBeak", (location[0], location[1] + 0.1, location[2] + 0.35), (0.1, 0.05, 0.05), beak_mat)

    # 鸭子的翅膀（使用球体代替）
    wing_left = create_sphere("DuckWingLeft", (location[0] - 0.15, location[1], location[2] + 0.05), (0.2, 0.05, 0.15), wing_mat)
    wing_right = create_sphere("DuckWingRight", (location[0] + 0.15, location[1], location[2] + 0.05), (0.2, 0.05, 0.15), wing_mat)

    # 鸭子的尾巴（使用小球体代替）
    tail = create_sphere("DuckTail", (location[0], location[1]-0.3, location[2]-0.05), (0.1, 0.1, 0.05), body_mat)

    # 鸭子的眼睛（两个小球体）
    eye_left = create_sphere("DuckEyeLeft", (location[0] - 0.06, location[1] - 0.05, location[2] + 0.37), (0.03, 0.05, 0.03), eye_mat)
    eye_right = create_sphere("DuckEyeRight", (location[0] + 0.06, location[1] - 0.05, location[2] + 0.37), (0.03, 0.05, 0.03), eye_mat)

    return [body, head, beak, wing_left, wing_right, tail, eye_left, eye_right]



def create_bear(location):
    body_mat = create_material("BearBody", (0.4, 0.2, 0.1))  # 棕色身体
    head_mat = create_material("BearHead", (0.6, 0.3, 0.1))  # 浅棕色头部
    eye_mat = create_material("BearEye", (0, 0, 0))  # 黑色眼睛
    paw_mat = create_material("BearPaw", (0.3, 0.1, 0))  # 深棕色的爪子
    
    # 熊的身体
    body = create_sphere("BearBody", location, (0.6, 0.5, 0.8), body_mat)  # 身体使用球体表示
    
    # 熊的头部
    head = create_sphere("BearHead", (location[0], location[1], location[2] + 1), (0.4, 0.4, 0.4), head_mat)
    
    # 熊的耳朵
    ear_left = create_sphere("BearEarLeft", (location[0] - 0.2, location[1] + 0.1, location[2] + 1.35), (0.1, 0.1, 0.1), head_mat)
    ear_right = create_sphere("BearEarRight", (location[0] + 0.2, location[1] + 0.1, location[2] + 1.35), (0.1, 0.1, 0.1), head_mat)

    # 熊的眼睛（使用小球体表示）
    eye_left = create_sphere("BearEyeLeft", (location[0] - 0.08, location[1] + 0.3, location[2] + 1.2), (0.05, 0.05, 0.05), eye_mat)
    eye_right = create_sphere("BearEyeRight", (location[0] + 0.08, location[1] + 0.3, location[2] + 1.2), (0.05, 0.05, 0.05), eye_mat)
    
    nose = create_sphere("BearNose", (location[0], location[1] + 0.4, location[2] + 1), (0.1, 0.05, 0.07), head_mat)
    
  
    # 熊的爪子（使用小球体）
    paw_left = create_sphere("BearPawLeft", (location[0] - 0.4, location[1] +0.4, location[2] + 0.4), (0.12, 0.12, 0.12), paw_mat)
    paw_right = create_sphere("BearPawRight", (location[0] + 0.4, location[1] +0.4, location[2] + 0.4), (0.12, 0.12, 0.12), paw_mat)

    return [body, head, ear_left, ear_right, eye_left, eye_right, nose, paw_left, paw_right]


def create_sphere(name, location, scale, material=None):
    bpy.ops.mesh.primitive_uv_sphere_add(radius=1, location=location)
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale
    if material:
        obj.data.materials.append(material)
    return obj

def create_cone(name, location, rotation_deg,scale, material=None):
    bpy.ops.mesh.primitive_cone_add(radius1=1, depth=2, location=location)
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale
    rotation_rad = (math.radians(rotation_deg[0]), math.radians(rotation_deg[1]), math.radians(rotation_deg[2]))   
    obj.rotation_euler = rotation_rad   
    if material:
        obj.data.materials.append(material)
    return obj

def create_cylinder(name, location, rotation_deg, scale, material=None):
    bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=2, location=location)
    obj = bpy.context.object
    obj.name = name
    obj.scale = scale
     # 将角度转换为弧度
    rotation_rad = (math.radians(rotation_deg[0]), math.radians(rotation_deg[1]), math.radians(rotation_deg[2]))   
    # 设置旋转角度
    obj.rotation_euler = rotation_rad
    if material:
        obj.data.materials.append(material)
    return obj


# 创建日光
def add_sun_light():
    # 添加一个光源，类型为 "SUN"
    bpy.ops.object.light_add(type='SUN', location=(0, 0, 15))  # 位置可以调整
    sun = bpy.context.object
    sun.name = "SunLight"
    # 设置光源强度（光的能量）
    sun.data.energy = 1.5  # 设置光源的强度，数值可以调整
    # 设置光源颜色
    sun.data.color = (0.5, 0.5, 1)  # 近似黄色的光
    # 设置光源的方向
    sun.rotation_euler = (math.radians(0), math.radians(45), math.radians(45))  # 设置光照角度，模拟太阳的位置



def create_tree(num_trees=10, radius=5, inner_radius=2, seed=42):
    random.seed(seed)  # 设置随机种子
    
    trunk_mat = create_material("TreeTrunkMaterial", (0.6, 0.3, 0.1)) 
    tree_mat = create_material("TreeMaterial", (0.1, 0.5, 0.1))
    
    for i in range(num_trees):
        # 随机决定树的大小
        tree_size = random.choice(["small"])

       # 使用随机种子计算树的位置
        while True:
            angle = random.uniform(0, 2 * math.pi)
            r = random.uniform(0, radius)  
            x = r * math.cos(angle) 
            y = r * math.sin(angle)
            z = -0.3

            # 检查是否位于排除的区域内
            if r >= inner_radius:  # 如果树的位置距离中心至少是 inner_radius，继续生成
                break  # 退出循环，开始生成树

        # 树干）
        trunk_height = random.uniform(1, 3)
        bpy.ops.mesh.primitive_cylinder_add(radius=0.2, depth=trunk_height, location=(x, y, z + trunk_height / 2))
        trunk = bpy.context.object
        trunk.name = "TreeTrunk"
        trunk.data.materials.append(trunk_mat)
        
        # 树冠
        if tree_size == "small":
            bpy.ops.mesh.primitive_cone_add(vertices=20, radius1=1, radius2=0, depth=2, location=(x, y, z + trunk_height + 1))
            tree_top = bpy.context.object
            tree_top.name = "TreeTop"
            tree_top.scale = (0.8, 0.8, 1)



        if tree_size == "small":
            tree_top.data.materials.append(tree_mat)



# 创建池子
def create_pool(radius, depth, water_height):
    water_mat = create_material("Water", (0.1, 0.4, 0.7))
    pool_mat = create_material("Pool", (0.5, 0.5, 0.5))

    # 创建池底
    bpy.ops.mesh.primitive_cylinder_add(radius=radius, depth=depth, location=(0, 0, -depth / 2))
    pool = bpy.context.object
    pool.name = "PoolBottom"
    pool.data.materials.append(pool_mat)

    # 创建水面
    bpy.ops.mesh.primitive_cylinder_add(radius=radius - 0.2, depth=water_height, location=(0, 0, water_height / 2))
    water = bpy.context.object
    water.name = "WaterSurface"
    water.data.materials.append(water_mat)

    return pool, water


# 创建环境
def create_env():
    plane_mat = create_material("Plane", (0.3, 0.8, 0.3))
    plane = create_cylinder("Plane", (0, 0, -0.2), (0, 0, 0), (10, 10, 0.1), plane_mat)

# 创建场景
def create_scene():
    create_env()
    create_tree(5,7,6,9)    
    # 创建池子
    pool, water = create_pool(radius=5, depth=0.5, water_height=0.05)
    # 创建鸭子
    create_duck((0,-2,0.1))
    # 创建熊
    create_bear((0, -5.5, 0.5))
    # 添加阳光
    add_sun_light()

# 生成场景
create_scene()
```

### 春园


 ![图片描述](https://doc.shiyanlou.com/courses/3584/labs/3553440/uid1190679-20250720-1753022358598/wm) 


```
import bpy
import math
import random
from mathutils import Vector


# 清除现有场景
def clear_scene():
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()


# 创建亭子
def create_pavilion(location=(0, 0, 0)):
    # 亭子底座
    bpy.ops.mesh.primitive_cylinder_add(
        vertices=8, radius=3, depth=0.5,
        location=(location[0], location[2], location[2] + 0.25)
    )
    base = bpy.context.object
    base.name = "Pavilion_Base"
    mat = bpy.data.materials.new(name="Base_Material")
    mat.diffuse_color = (0.7, 0.3, 0.1, 1.0)
    base.data.materials.append(mat)

    # 亭子柱子
    for i in range(8):
        angle = math.pi * 2 * i / 8
        x = math.cos(angle) * 2
        y = math.sin(angle) * 2
        bpy.ops.mesh.primitive_cylinder_add(
            vertices=8, radius=0.2, depth=3,
            location=(location[0] + x, location[2] + y, location[2] + 2)
        )
        column = bpy.context.object
        column.name = f"Pavilion_Column_{i}"
        mat = bpy.data.materials.new(name="Column_Material")
        mat.diffuse_color = (0.5, 0.1, 0.1, 1.0)
        column.data.materials.append(mat)

    # 亭子顶部
    bpy.ops.mesh.primitive_cone_add(
        vertices=8, radius1=3.5, radius2=0, depth=3,
        location=(location[0], location[2], location[2] + 4.5)
    )
    roof = bpy.context.object
    roof.name = "Pavilion_Roof"
    mat = bpy.data.materials.new(name="Roof_Material")
    mat.diffuse_color = (0.7, 0.3, 0.1, 1.0)
    roof.data.materials.append(mat)

    # 亭子顶部装饰
    bpy.ops.mesh.primitive_uv_sphere_add(
        radius=0.3, location=(location[0], location[2], location[2] + 6)
    )
    decoration = bpy.context.object
    decoration.name = "Pavilion_Decoration"
    mat = bpy.data.materials.new(name="Decoration_Material")
    mat.diffuse_color = (0.7, 0.3, 0.1, 1.0)
    decoration.data.materials.append(mat)

    # 将所有部分组合
    bpy.ops.object.select_all(action='DESELECT')
    for obj in bpy.data.objects:
        if obj.name.startswith("Pavilion"):
            obj.select_set(True)
    bpy.context.view_layer.objects.active = base
    bpy.ops.object.join()
    base.name = "Suzhou_Pavilion"


# 创建树木
def create_tree(location=(0, 0, 0)):
    # 树干
    bpy.ops.mesh.primitive_cylinder_add(
        vertices=8, radius=0.3, depth=3,
        location=(location[0], location[1], location[2] + 1.5)
    )
    trunk = bpy.context.object
    trunk.name = "Tree_Trunk"
    mat = bpy.data.materials.new(name="Trunks_Material")
    mat.diffuse_color = (0.6, 0.4, 0.2, 1)
    trunk.data.materials.append(mat)

    # 树冠 - 多层球体叠加
    for i in range(3):
        size = 2 - i * 0.5
        height = 3 + i * 1.2
        bpy.ops.mesh.primitive_uv_sphere_add(
            radius=size,
            location=(location[0], location[1], location[2] + height),
            segments=8, ring_count=6
        )
        leaves = bpy.context.object
        leaves.name = f"Tree_Leaves_{i}"
        mat = bpy.data.materials.new(name="Leaves_Material")
        mat.diffuse_color = (0.2, 0.6, 0.3, 1)
        leaves.data.materials.append(mat)

    # 将所有部分组合
    bpy.ops.object.select_all(action='DESELECT')
    for obj in bpy.data.objects:
        if obj.name.startswith("Tree"):
            obj.select_set(True)
    bpy.context.view_layer.objects.active = trunk
    bpy.ops.object.join()
    trunk.name = "Suzhou_Tree"


# 创建草丛
def create_grass_patch(location=(0, 0, 0), count=10):
    bpy.ops.object.select_all(action='DESELECT')

    # 创建多个草叶
    for i in range(count):
        x = location[0] + random.uniform(-2, 2)
        y = location[1] + random.uniform(-2, 2)
        z = location[2]

        # 草叶 - 使用细长的立方体
        bpy.ops.mesh.primitive_cube_add(
            size=1,
            location=(x, y, z + 0.5)
        )
        grass = bpy.context.object
        grass.name = f"Grass_{i}"
        mat = bpy.data.materials.new(name="Grass_Material")
        mat.diffuse_color = (0.2, 0.6, 0.3, 1)
        grass.data.materials.append(mat)

        # 缩放和旋转草叶
        grass.scale = (0.05, 0.05, random.uniform(0.3, 0.8))
        grass.rotation_euler = (
            random.uniform(-0.2, 0.2),
            random.uniform(-0.2, 0.2),
            random.uniform(0, math.pi * 2)
        )

    # 将所有草叶组合
    bpy.ops.object.select_all(action='DESELECT')
    for obj in bpy.data.objects:
        if obj.name.startswith("Grass"):
            obj.select_set(True)
    if bpy.context.selected_objects:
        bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
        bpy.ops.object.join()
        bpy.context.object.name = "Suzhou_Grass_Patch"


# 创建假山
def create_rock(location=(0, 0, 0)):
    # 使用多个变形球体创建假山
    bpy.ops.object.select_all(action='DESELECT')

    for i in range(5):
        x = location[0] + random.uniform(-1, 1)
        y = location[1] + random.uniform(-1, 1)
        z = location[2] + random.uniform(0, 0.5)

        bpy.ops.mesh.primitive_uv_sphere_add(
            radius=random.uniform(0.5, 1.5),
            location=(x, y, z),
            segments=8, ring_count=6
        )
        rock_part = bpy.context.object
        rock_part.name = f"Rock_Part_{i}"
        mat = bpy.data.materials.new(name="Rock_Material")
        mat.diffuse_color = (0.3, 0.3, 0.3, 1)
        rock_part.data.materials.append(mat)

        # 随机缩放和旋转
        rock_part.scale = (
            random.uniform(0.8, 1.2),
            random.uniform(0.8, 1.2),
            random.uniform(0.8, 1.5)
        )
        rock_part.rotation_euler = (
            random.uniform(0, math.pi / 4),
            random.uniform(0, math.pi / 4),
            random.uniform(0, math.pi / 4)
        )

    # 将所有部分组合
    bpy.ops.object.select_all(action='DESELECT')
    for obj in bpy.data.objects:
        if obj.name.startswith("Rock_Part"):
            obj.select_set(True)
    if bpy.context.selected_objects:
        bpy.context.view_layer.objects.active = bpy.context.selected_objects[0]
        bpy.ops.object.join()
        bpy.context.object.name = "Suzhou_Rock"


# 创建湖
def create_lake(location=(0, 0, 0), size=6):
    # 湖面 - 使用扁平圆柱体
    bpy.ops.mesh.primitive_cylinder_add(
        vertices=32, radius=size, depth=0.1,
        location=(location[0], location[1], location[2] - 0.05)
    )
    lake = bpy.context.object
    lake.name = "Suzhou_Lake"
    mat = bpy.data.materials.new(name="Lake_Material")
    mat.diffuse_color = (0.1, 0.3, 0.8, 1)
    lake.data.materials.append(mat)


# 创建桥
def create_bridge(location=(0, 0, 0), length=5):
    # 桥面
    bpy.ops.mesh.primitive_cube_add(
        size=2.7,
        location=(location[0], location[1], location[2] + 0.5),
        scale=(length, 1, 0.1)
    )
    bridge_deck = bpy.context.object
    bridge_deck.name = "Bridge_Deck"
    mat = bpy.data.materials.new(name="Deck_Material")
    mat.diffuse_color = (0.4, 0.4, 0.4, 1)
    bridge_deck.data.materials.append(mat)

    # 桥栏杆
    for side in [-1, 1]:
        for i in range(int(length * 2.7) + 1):
            x = location[0] + i - length - 2
            y = location[1] + side
            bpy.ops.mesh.primitive_cylinder_add(
                vertices=6, radius=0.05, depth=1,
                location=(x, y, location[2] + 0.8)
            )
            railing_post = bpy.context.object
            railing_post.name = f"Bridge_Railing_Post_{side}_{i}"
            mat = bpy.data.materials.new(name="Railing_Post_Material")
            mat.diffuse_color = (0.4, 0.4, 0.4, 1)
            railing_post.data.materials.append(mat)

        # 连接栏杆
        bpy.ops.mesh.primitive_cube_add(
            size=2.7,
            location=(location[0], location[1] + side, location[2] + 0.8),
            scale=(length, 0.05, 0.05)
        )
        railing_beam = bpy.context.object
        railing_beam.name = f"Bridge_Railing_Beam_{side}"
        mat = bpy.data.materials.new(name="Railing_Beam_Material")
        mat.diffuse_color = (0.4, 0.4, 0.4, 1)
        railing_beam.data.materials.append(mat)

    # 将所有部分组合
    bpy.ops.object.select_all(action='DESELECT')
    for obj in bpy.data.objects:
        if obj.name.startswith("Bridge"):
            obj.select_set(True)
    bpy.context.view_layer.objects.active = bridge_deck
    bpy.ops.object.join()
    bridge_deck.name = "Suzhou_Bridge"


# 设置全景摄像机
def setup_panorama_camera():
    # 计算场景边界（根据园林布局调整）
    min_x, max_x = -25, 25
    min_y, max_y = -25, 25
    center = ((min_x + max_x) / 2, (min_y + max_y) / 2, 0)

    # 动态计算摄像机参数
    scene_size = max(max_x - min_x, max_y - min_y)
    camera_height = scene_size * 0.8
    orbit_radius = scene_size * 1.5  # 摄像机轨道半径

    # 删除旧摄像机（避免冲突）
    for obj in bpy.data.objects:
        if obj.type == 'CAMERA':
            bpy.data.objects.remove(obj, do_unlink=True)

    # 创建焦点空物体
    bpy.ops.object.empty_add(location=center)
    focus = bpy.context.object
    focus.name = "Camera_Focus"

    # 设置动画范围
    bpy.context.scene.frame_start = 1
    bpy.context.scene.frame_end = 250

    # 创建初始摄像机位置（设置在X轴和Y轴中间位置）
    initial_angle = math.pi / 4  # 45度角，位于X和Y轴中间
    cam_x = center[0] + math.cos(initial_angle) * orbit_radius
    cam_y = center[1] + math.sin(initial_angle) * orbit_radius

    bpy.ops.object.camera_add(
        location=(cam_x, cam_y, camera_height),
        rotation=(math.pi / 3, 0, initial_angle + math.pi / 2)  # 60度俯角
    )
    camera = bpy.context.object
    camera.name = "Panorama_Camera"

    # 摄像机参数设置
    camera.data.type = 'PERSP'
    camera.data.lens = 35  # 35mm广角
    camera.data.clip_start = 0.1
    camera.data.clip_end = 500

    # 添加追踪约束
    track = camera.constraints.new('TRACK_TO')
    track.target = focus
    track.track_axis = 'TRACK_NEGATIVE_Z'
    track.up_axis = 'UP_Y'

    # 设为活动摄像机
    bpy.context.scene.camera = camera

    # 创建动画
    if not camera.animation_data:
        camera.animation_data_create()

    # 清除旧的关键帧（如果有）
    if camera.animation_data.action:
        for fcurve in camera.animation_data.action.fcurves:
            camera.animation_data.action.fcurves.remove(fcurve)

    # 设置关键帧动画 - 让摄像机围绕中心点旋转
    for frame in [1, 125, 250]:
        # 计算当前角度（从初始角度开始旋转）
        progress = (frame - 1) / (250 - 1)
        angle = initial_angle + 2 * math.pi * progress

        # 更新摄像机位置
        camera.location.x = center[0] + math.cos(angle) * orbit_radius
        camera.location.y = center[1] + math.sin(angle) * orbit_radius
        camera.location.z = camera_height

        # 插入关键帧
        camera.keyframe_insert(data_path="location", frame=frame)

    # 强制刷新动画系统
    bpy.context.view_layer.update()

    print(f"已创建摄像机动画：初始位置在X/Y轴中间，将在{orbit_radius}半径的轨道上围绕中心旋转")

    return camera


# 创建整个苏州园林场景
def create_suzhou_garden():
    clear_scene()

    # 创建地面
    bpy.ops.mesh.primitive_plane_add(size=1000, location=(0, 0, -0.1))
    ground = bpy.context.object
    ground.name = "Ground"

    # 设置地面材质为绿色
    mat = bpy.data.materials.new(name="Ground_Material")
    mat.diffuse_color = (0.2, 0.6, 0.3, 1)
    ground.data.materials.append(mat)

    # 创建湖
    create_lake(location=(5, 2, 0), size=8)

    # 创建桥
    create_bridge(location=(5, 0, 0.2), length=6)

    # 创建亭子
    create_pavilion(location=(-5.5, -5, 0))
    create_pavilion(location=(15.5, 5, 0))

    # 创建树木
    for i in range(10):
        x = random.uniform(-20, 20)
        y = random.uniform(-20, 20)
        if math.sqrt((x - 5) ** 2 + y ** 2) > 10:
            create_tree(location=(x, y, 0))

    # 创建草丛
    for i in range(15):
        x = random.uniform(-20, 20)
        y = random.uniform(-20, 20)
        if math.sqrt((x - 5) ** 2 + y ** 2) > 10:
            create_grass_patch(location=(x, y, 0), count=random.randint(5, 15))

    # 创建假山
    create_rock(location=(12, -8, 0))
    create_rock(location=(-8, 10, 0))
    create_rock(location=(-10, -12, 0))

    # 设置全景摄像机
    setup_panorama_camera()

    # 设置光源
    bpy.ops.object.light_add(type='SUN', location=(10, -10, 20))
    light = bpy.context.object
    light.name = "Sun_Light"
    light.data.energy = 2.0
    light.data.angle = math.radians(5)  # 使用light变量

    # 添加补光
    bpy.ops.object.light_add(type='AREA', location=(0, 0, 20))
    fill = bpy.context.object
    fill.name = "Fill_Light"
    fill.data.energy = 500
    fill.data.size = 30

    # 渲染设置
    bpy.context.scene.render.engine = 'CYCLES'
    bpy.context.scene.render.resolution_x = 3840
    bpy.context.scene.render.resolution_y = 2160
    bpy.context.scene.render.fps = 24
    bpy.context.scene.render.image_settings.file_format = 'FFMPEG'
    bpy.context.scene.render.ffmpeg.format = 'MPEG4'
    bpy.context.scene.render.ffmpeg.codec = 'H264'
    bpy.context.scene.render.filepath = "//panorama_animation.mp4"


# 执行创建场景
create_suzhou_garden()

# 自动跳转到起始帧并播放
bpy.context.scene.frame_set(1)
bpy.ops.screen.animation_play()
```